<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do Universe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
            pointer-events: none;
        }

        #radar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 140px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            border-radius: 8px;
            pointer-events: all;
        }

        #radar-canvas {
            width: 100%;
            height: 100%;
        }

        #system-messages {
            position: absolute;
            bottom: 20px;
            left: 20px;
            max-width: 400px;
            pointer-events: none;
        }

        .message {
            background: rgba(0, 0, 0, 0.9);
            border-left: 4px solid;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.3s ease;
        }

        .message.info { border-color: #0ff; }
        .message.success { border-color: #0f0; }
        .message.warning { border-color: #ff0; }
        .message.error { border-color: #f0f; }

        .message.visible {
            opacity: 1;
            transform: translateX(0);
        }

        #side-menu-toggle {
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            border-right: none;
            color: #0ff;
            padding: 15px 10px;
            cursor: pointer;
            border-radius: 8px 0 0 8px;
            z-index: 20;
            pointer-events: all;
            transition: all 0.3s ease;
        }

        #side-menu-toggle:hover {
            background: #0ff;
            color: #000;
        }

        #side-menu {
            position: absolute;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            border-left: 2px solid #0ff;
            transition: right 0.3s ease;
            pointer-events: all;
            display: flex;
            flex-direction: column;
            padding: 20px;
            z-index: 15;
        }

        #side-menu.visible {
            right: 0;
        }

        .menu-button {
            background: transparent;
            border: 1px solid #0ff;
            color: #0ff;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .menu-button:hover {
            background: #0ff;
            color: #000;
        }

        .depth-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
        }

        .depth-btn {
            font-size: 12px;
            padding: 8px 12px;
        }

        .speed-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #0ff;
            border-radius: 5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .control-group label {
            font-size: 11px;
            color: #0ff;
            font-weight: bold;
        }

        .control-group input {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            color: #fff;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .control-group input:focus {
            outline: none;
            border-color: #fff;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: all;
        }

        .modal-content {
            background: #111;
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        #time-travel-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: all;
        }

        .time-travel-content {
            background: #111;
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .time-entry {
            background: #000;
            border: 1px solid #0ff;
            color: #fff;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .time-entry:hover {
            background: #0ff;
            color: #000;
        }

        .modal-input {
            width: 100%;
            background: #000;
            border: 1px solid #0ff;
            color: #fff;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-family: inherit;
        }

        .modal-button {
            background: #0ff;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            margin-right: 10px;
        }

        #context-menu {
            position: fixed;
            background: #111;
            border: 1px solid #0ff;
            border-radius: 4px;
            padding: 5px 0;
            z-index: 50;
            display: none;
            pointer-events: all;
        }

        .context-item {
            padding: 8px 15px;
            cursor: pointer;
            color: #fff;
        }

        .context-item:hover {
            background: #0ff;
            color: #000;
        }

        .task-card {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid;
            border-radius: 8px;
            padding: 15px;
            min-width: 200px;
            max-width: 300px;
            cursor: grab;
            transition: all 0.3s ease;
            z-index: 5;
            pointer-events: all;
            user-select: none;
        }

        .task-card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px currentColor;
        }

        .task-card.dragging {
            cursor: grabbing;
            z-index: 100;
            transform: scale(1.1);
        }

        .task-card.dragging:hover {
            transform: scale(1.1);
        }

        .task-card.high { border-color: #f00; color: #f00; }
        .task-card.medium { border-color: #ff0; color: #ff0; }
        .task-card.low { border-color: #0f0; color: #0f0; }

        .task-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .task-brief {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .task-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }

        .task-tag {
            background: currentColor;
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        @media (max-width: 600px) {
            #radar {
                width: 100px;
                height: 70px;
                top: 10px;
                left: 10px;
            }

            #system-messages {
                bottom: 10px;
                left: 10px;
                max-width: 300px;
            }

            #side-menu {
                width: 250px;
                right: -250px;
            }

            .task-card {
                min-width: 150px;
                max-width: 250px;
            }
        }

        @media (max-width: 1024px) {
            .modal-content {
                width: 95%;
                margin: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
    </div>

    <div id="ui-overlay">
        <div id="radar">
            <canvas id="radar-canvas"></canvas>
        </div>

        <div id="system-messages"></div>

        <div id="side-menu-toggle">
            <span>⚙️</span>
        </div>

        <div id="side-menu">
            <button class="menu-button" id="new-task">
                <span>✨</span> New Task
            </button>
            <div class="depth-buttons">
                <button class="menu-button depth-btn" data-depth="-5">
                    <span>🔽</span> Deep (-5)
                </button>
                <button class="menu-button depth-btn" data-depth="0">
                    <span>➡️</span> Mid (0)
                </button>
                <button class="menu-button depth-btn" data-depth="10">
                    <span>🔼</span> Near (10)
                </button>
                <button class="menu-button depth-btn" data-depth="5">
                    <span>🔝</span> Close (5)
                </button>
            </div>
            <div class="speed-controls">
                <div class="control-group">
                    <label>Orbit Radius:</label>
                    <input type="number" id="orbit-radius" value="25" step="0.1" min="0.1">
                </div>
                <div class="control-group">
                    <label>Orbit Speed:</label>
                    <input type="number" id="orbit-speed" value="0.4" step="0.01" min="0.01">
                </div>
                <div class="control-group">
                    <label>Card Drag Speed:</label>
                    <input type="number" id="card-drag-speed" value="0.5" step="0.01" min="0.01">
                </div>
                <div class="control-group">
                    <label>Universe Drag Speed:</label>
                    <input type="number" id="universe-drag-speed" value="0.1" step="0.001" min="0.001">
                </div>
            </div>
            <button class="menu-button" id="save-state">
                <span>💾</span> Save State
            </button>
            <button class="menu-button" id="time-travel">
                <span>⏰</span> Time Travel
            </button>
            <button class="menu-button" id="export-json">
                <span>📤</span> Export JSON
            </button>
            <button class="menu-button" id="import-json">
                <span>📥</span> Import JSON
            </button>
            <button class="menu-button" id="orbit-mode">
                <span>🔄</span> Orbit Mode
            </button>
            <button class="menu-button" id="reset-camera">
                <span>🎯</span> Reset Camera
            </button>
        </div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h3>Edit Task</h3>
            <input type="text" class="modal-input" id="modal-title" placeholder="Title">
            <textarea class="modal-input" id="modal-brief" placeholder="Brief description" rows="3"></textarea>
            <input type="text" class="modal-input" id="modal-links" placeholder="Links (comma-separated)">
            <input type="text" class="modal-input" id="modal-tags" placeholder="Tags (comma-separated)">
            <select class="modal-input" id="modal-priority">
                <option value="low">Low Priority</option>
                <option value="medium">Medium Priority</option>
                <option value="high">High Priority</option>
            </select>
            <div style="margin-top: 15px;">
                <button class="modal-button" id="modal-save">Save</button>
                <button class="modal-button" id="modal-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="time-travel-modal">
        <div class="time-travel-content">
            <h3>Time Travel</h3>
            <p>Select a point in time to travel to:</p>
            <div id="time-entries"></div>
            <div style="margin-top: 15px;">
                <button class="modal-button" id="time-travel-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="context-menu">
        <div class="context-item" data-action="edit">Edit</div>
        <div class="context-item" data-action="duplicate">Duplicate</div>
        <div class="context-item" data-action="follow">Follow</div>
        <div class="context-item" data-action="delete">Delete</div>
    </div>

    <script>
        // Core utilities
        class Utils {
            static uuidv4() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            static hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`;
            }

            static getRandomNeonColor() {
                const hue = Math.random() * 360;
                const saturation = 80 + Math.random() * 20;
                const lightness = 50 + Math.random() * 20;
                return this.hslToHex(hue, saturation, lightness);
            }

            static debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }

        // Task data model
        class Task {
            constructor(data = {}) {
                this.id = data.id || Utils.uuidv4();
                this.title = data.title || 'New Task';
                this.brief = data.brief || '';
                this.links = data.links || [];
                this.tags = data.tags || [];
                this.priority = data.priority || 'medium';
                this.coords = data.coords || { x: 0, y: 0, z: 0 };
                this.color = data.color || Utils.getRandomNeonColor();
                this.createdAt = data.createdAt || new Date();
                this.updatedAt = data.updatedAt || new Date();
            }

            update(data) {
                Object.assign(this, data);
                this.updatedAt = new Date();
            }
        }

        // State management with time travel
        class StateManager {
            constructor() {
                this.tasks = new Map();
                this.savedStates = [];
                this.currentStateIndex = -1;
                this.loadFromStorage();
                this.saveCurrentState();
            }

            addTask(task) {
                this.tasks.set(task.id, task);
                this.saveToStorage();
                this.saveCurrentState();
                return task;
            }

            updateTask(id, data) {
                const task = this.tasks.get(id);
                if (task) {
                    task.update(data);
                    this.saveToStorage();
                    this.saveCurrentState();
                }
                return task;
            }

            deleteTask(id) {
                const deleted = this.tasks.delete(id);
                if (deleted) {
                    this.saveToStorage();
                    this.saveCurrentState();
                }
                return deleted;
            }

            getTask(id) {
                return this.tasks.get(id);
            }

            getAllTasks() {
                return Array.from(this.tasks.values());
            }

            saveCurrentState() {
                const state = {
                    tasks: this.getAllTasks().map(task => ({
                        id: task.id,
                        title: task.title,
                        brief: task.brief,
                        links: [...task.links],
                        tags: [...task.tags],
                        priority: task.priority,
                        coords: { ...task.coords },
                        color: task.color,
                        createdAt: task.createdAt,
                        updatedAt: task.updatedAt
                    })),
                    timestamp: new Date().toISOString(),
                    description: `State saved at ${new Date().toLocaleString()}`
                };
                
                // Keep only last 10 states
                this.savedStates.push(state);
                if (this.savedStates.length > 10) {
                    this.savedStates.shift();
                }
                this.currentStateIndex = this.savedStates.length - 1;
                
                // Save to localStorage
                try {
                    localStorage.setItem('todo-universe-saved-states', JSON.stringify(this.savedStates));
                } catch (e) {
                    console.error('Failed to save states:', e);
                }
            }

            loadState(index) {
                if (index >= 0 && index < this.savedStates.length) {
                    const state = this.savedStates[index];
                    this.tasks.clear();
                    state.tasks.forEach(taskData => {
                        const task = new Task(taskData);
                        this.tasks.set(task.id, task);
                    });
                    this.currentStateIndex = index;
                    // Don't save to storage when loading a state - this prevents new changes
                    return true;
                }
                return false;
            }

            getSavedStates() {
                return this.savedStates.map((state, index) => ({
                    ...state,
                    index
                }));
            }

            saveToStorage() {
                try {
                    const data = {
                        tasks: this.getAllTasks(),
                        timestamp: new Date().toISOString()
                    };
                    localStorage.setItem('todo-universe-state', JSON.stringify(data));
                } catch (e) {
                    console.error('Failed to save state:', e);
                }
            }

            loadFromStorage() {
                try {
                    const data = localStorage.getItem('todo-universe-state');
                    if (data) {
                        const parsed = JSON.parse(data);
                        this.tasks.clear();
                        parsed.tasks.forEach(taskData => {
                            const task = new Task(taskData);
                            this.tasks.set(task.id, task);
                        });
                    }
                    
                    // Load saved states
                    const savedStatesData = localStorage.getItem('todo-universe-saved-states');
                    if (savedStatesData) {
                        this.savedStates = JSON.parse(savedStatesData);
                        this.currentStateIndex = this.savedStates.length - 1;
                    }
                } catch (e) {
                    console.error('Failed to load state:', e);
                }
            }

            exportJSON() {
                return JSON.stringify({
                    tasks: this.getAllTasks(),
                    timestamp: new Date().toISOString()
                }, null, 2);
            }

            importJSON(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    this.tasks.clear();
                    data.tasks.forEach(taskData => {
                        const task = new Task(taskData);
                        this.tasks.set(task.id, task);
                    });
                    this.saveToStorage();
                    this.saveCurrentState();
                    return true;
                } catch (e) {
                    console.error('Failed to import JSON:', e);
                    return false;
                }
            }
        }

        // System message manager
        class MessageManager {
            constructor() {
                this.container = document.getElementById('system-messages');
                this.messages = [];
                this.maxMessages = 5;
            }

            add(type, text) {
                const message = document.createElement('div');
                message.className = `message ${type}`;
                message.textContent = text;
                
                this.container.appendChild(message);
                this.messages.push(message);

                setTimeout(() => message.classList.add('visible'), 10);
                this.typewriter(message, text);

                if (this.messages.length > this.maxMessages) {
                    const oldMessage = this.messages.shift();
                    oldMessage.classList.remove('visible');
                    setTimeout(() => oldMessage.remove(), 300);
                }
            }

            typewriter(element, text) {
                element.textContent = '';
                let i = 0;
                const speed = 60;
                
                const type = () => {
                    if (i < text.length) {
                        element.textContent += text.charAt(i);
                        i++;
                        setTimeout(type, speed);
                    }
                };
                type();
            }

            info(text) { this.add('info', text); }
            success(text) { this.add('success', text); }
            warning(text) { this.add('warning', text); }
            error(text) { this.add('error', text); }
        }

        // Task renderer with proper 3D positioning and dragging
        class TaskRenderer {
            constructor() {
                this.container = document.getElementById('ui-overlay');
                this.tasks = new Map();
                this.draggedTask = null;
                this.dragOffset = { x: 0, y: 0 };
                this.camera = { x: 0, y: 0, z: 5 };
                this.zoom = 1;
            }

            createTaskElement(task) {
                const element = document.createElement('div');
                element.className = `task-card ${task.priority}`;
                element.dataset.taskId = task.id;
                element.style.borderColor = task.color;
                element.style.color = task.color;

                element.innerHTML = `
                    <div class="task-title">${task.title}</div>
                    <div class="task-brief">${task.brief}</div>
                    <div class="task-tags">
                        ${task.tags.map(tag => `<span class="task-tag">${tag}</span>`).join('')}
                    </div>
                `;

                this.setupTaskEvents(element, task);
                return element;
            }

            setupTaskEvents(element, task) {
                let isDragging = false;
                let startMousePos = { x: 0, y: 0 };
                let startTaskPos = { x: 0, y: 0 };

                const handleMouseDown = (e) => {
                    if (e.button === 0) { // Left click only
                        isDragging = true;
                        this.draggedTask = task;
                        startMousePos = { x: e.clientX, y: e.clientY };
                        startTaskPos = { x: task.coords.x, y: task.coords.y };
                        
                        // Calculate offset from mouse to card center
                        const rect = element.getBoundingClientRect();
                        this.dragOffset = {
                            x: e.clientX - (rect.left + rect.width / 2),
                            y: e.clientY - (rect.top + rect.height / 2)
                        };
                        
                        element.classList.add('dragging');
                        element.style.zIndex = '1000';
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };

                const handleMouseMove = (e) => {
                    if (isDragging && this.draggedTask === task) {
                        // Convert screen coordinates to world coordinates with correct Y-axis and configurable sensitivity
                        const dragSpeed = window.app ? window.app.cardDragSpeed : 0.5;
                        const worldX = (e.clientX - window.innerWidth / 2) * dragSpeed;
                        const worldY = (e.clientY - window.innerHeight / 2) * dragSpeed;
                        
                        task.coords.x = worldX;
                        task.coords.y = worldY;
                        
                        this.updateTaskPosition(task);
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };

                const handleMouseUp = () => {
                    if (isDragging && this.draggedTask === task) {
                        isDragging = false;
                        this.draggedTask = null;
                        element.classList.remove('dragging');
                        element.style.zIndex = '5';
                        
                        // Save the new position
                        if (window.app && window.app.stateManager) {
                            window.app.stateManager.updateTask(task.id, { coords: task.coords });
                        }
                    }
                };

                element.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                element.addEventListener('dblclick', (e) => {
                    if (!isDragging) {
                        this.editTask(task);
                    }
                });

                element.addEventListener('contextmenu', (e) => {
                    if (!isDragging) {
                        this.showContextMenu(e, task);
                    }
                });

                // Touch events for mobile
                element.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        isDragging = true;
                        this.draggedTask = task;
                        startMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        startTaskPos = { x: task.coords.x, y: task.coords.y };
                        
                        const rect = element.getBoundingClientRect();
                        this.dragOffset = {
                            x: e.touches[0].clientX - (rect.left + rect.width / 2),
                            y: e.touches[0].clientY - (rect.top + rect.height / 2)
                        };
                        
                        element.classList.add('dragging');
                        element.style.zIndex = '1000';
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });

                document.addEventListener('touchmove', (e) => {
                    if (isDragging && this.draggedTask === task && e.touches.length === 1) {
                        const worldX = (e.touches[0].clientX - window.innerWidth / 2) * 0.05;
                        const worldY = (e.touches[0].clientY - window.innerHeight / 2) * 0.05;
                        
                        task.coords.x = worldX;
                        task.coords.y = worldY;
                        
                        this.updateTaskPosition(task);
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });

                document.addEventListener('touchend', () => {
                    if (isDragging && this.draggedTask === task) {
                        isDragging = false;
                        this.draggedTask = null;
                        element.classList.remove('dragging');
                        element.style.zIndex = '5';
                        
                        if (window.app && window.app.stateManager) {
                            window.app.stateManager.updateTask(task.id, { coords: task.coords });
                        }
                    }
                });
            }

            updateTaskPosition(task) {
                const element = this.tasks.get(task.id);
                if (element) {
                    // Get camera from the main app, with fallback
                    const camera = window.app ? window.app.camera : { x: 0, y: 0, z: 5 };
                    const zoom = window.app ? window.app.zoom : 1;
                    
                    // Proper 3D projection with camera position and zoom
                    const worldX = task.coords.x - camera.x;
                    const worldY = task.coords.y - camera.y;
                    const worldZ = task.coords.z - camera.z;
                    
                    // Apply zoom factor
                    const zoomedX = worldX * zoom;
                    const zoomedY = worldY * zoom;
                    
                    // Convert to screen coordinates (center of screen is origin)
                    const screenX = window.innerWidth / 2 + zoomedX;
                    const screenY = window.innerHeight / 2 + zoomedY;
                    
                    // Apply depth-based scaling and opacity
                    const distance = Math.abs(worldZ);
                    const scale = Math.max(0.1, 1 / (1 + distance * 0.2)) * zoom;
                    const opacity = Math.max(0.3, 1 / (1 + distance * 0.1));
                    
                    element.style.transform = `translate(${screenX}px, ${screenY}px) scale(${scale})`;
                    element.style.opacity = opacity;
                    element.style.zIndex = Math.floor(1000 - distance * 10);
                }
            }

            addTask(task) {
                const element = this.createTaskElement(task);
                this.container.appendChild(element);
                this.tasks.set(task.id, element);
                this.updateTaskPosition(task);
            }

            removeTask(taskId) {
                const element = this.tasks.get(taskId);
                if (element) {
                    element.remove();
                    this.tasks.delete(taskId);
                }
            }

            editTask(task) {
                const modal = document.getElementById('modal');
                const titleInput = document.getElementById('modal-title');
                const briefInput = document.getElementById('modal-brief');
                const linksInput = document.getElementById('modal-links');
                const tagsInput = document.getElementById('modal-tags');
                const prioritySelect = document.getElementById('modal-priority');

                titleInput.value = task.title;
                briefInput.value = task.brief;
                linksInput.value = task.links.join(', ');
                tagsInput.value = task.tags.join(', ');
                prioritySelect.value = task.priority;

                modal.style.display = 'flex';
                modal.dataset.editingTaskId = task.id;
            }

            showContextMenu(e, task) {
                e.preventDefault();
                const menu = document.getElementById('context-menu');
                menu.style.display = 'block';
                menu.style.left = e.clientX + 'px';
                menu.style.top = e.clientY + 'px';
                menu.dataset.taskId = task.id;
            }

            updateAllPositions() {
                this.stateManager.getAllTasks().forEach(task => {
                    this.updateTaskPosition(task);
                });
            }
        }

        // Radar system
        class Radar {
            constructor() {
                this.canvas = document.getElementById('radar-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', Utils.debounce(() => this.resize(), 150));
            }

            resize() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
            }

            render(tasks, camera) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw border
                this.ctx.strokeStyle = '#0ff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(2, 2, this.canvas.width - 4, this.canvas.height - 4);

                // Calculate view bounds based on camera and zoom
                const viewRange = 50 / (window.app ? window.app.zoom : 1); // Adjust based on zoom level
                const minX = camera.x - viewRange;
                const maxX = camera.x + viewRange;
                const minY = camera.y - viewRange;
                const maxY = camera.y + viewRange;

                // Draw tasks relative to camera position
                tasks.forEach(task => {
                    const relativeX = task.coords.x - camera.x;
                    const relativeY = task.coords.y - camera.y;
                    
                    // Only show tasks within view range
                    if (Math.abs(relativeX) <= viewRange && Math.abs(relativeY) <= viewRange) {
                        const x = ((relativeX + viewRange) / (viewRange * 2)) * this.canvas.width;
                        const y = ((relativeY + viewRange) / (viewRange * 2)) * this.canvas.height;
                        
                        this.ctx.fillStyle = task.priority === 'high' ? '#f00' : 
                                           task.priority === 'medium' ? '#ff0' : '#0f0';
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });

                // Draw camera position (center of radar)
                const camX = this.canvas.width / 2;
                const camY = this.canvas.height / 2;
                
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(camX - 5, camY);
                this.ctx.lineTo(camX + 5, camY);
                this.ctx.moveTo(camX, camY - 5);
                this.ctx.lineTo(camX, camY + 5);
                this.ctx.stroke();
            }
        }

        // Starfield background
        class Starfield {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.stars = [];
                this.resize();
                this.generateStars();
                window.addEventListener('resize', Utils.debounce(() => this.resize(), 150));
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
            }

            generateStars() {
                this.stars = [];
                const starCount = 500;
                
                for (let i = 0; i < starCount; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 0.5,
                        brightness: Math.random() * 0.8 + 0.2,
                        twinkle: Math.random() * Math.PI * 2
                    });
                }
            }

            render(camera) {
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Parallax effect based on camera movement
                const parallaxX = camera.x * 0.1;
                const parallaxY = camera.y * 0.1;

                this.stars.forEach(star => {
                    const x = (star.x + parallaxX) % this.canvas.width;
                    const y = (star.y + parallaxY) % this.canvas.height;
                    
                    // Twinkling effect
                    const twinkle = Math.sin(Date.now() * 0.001 + star.twinkle) * 0.3 + 0.7;
                    const brightness = star.brightness * twinkle;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
        }

        // Main application with proper 3D navigation and orbital motion
        class TodoUniverse {
            constructor() {
                this.stateManager = new StateManager();
                this.messageManager = new MessageManager();
                this.taskRenderer = new TaskRenderer();
                this.radar = new Radar();
                this.starfield = new Starfield();
                
                this.camera = { x: 0, y: 0, z: 5 };
                this.zoom = 1;
                this.orbitMode = false;
                this.isDraggingUniverse = false;
                this.lastMousePos = { x: 0, y: 0 };
                this.orbitData = new Map(); // Store orbital parameters for each task
                
                // Speed control properties
                this.orbitRadius = 25;
                this.orbitSpeed = 0.4;
                this.cardDragSpeed = 0.5;
                this.universeDragSpeed = 0.1;
                
                this.setupEventListeners();
                this.initializeTasks();
                this.startRenderLoop();
                this.initializeOrbitData();
            }

            initializeOrbitData() {
                this.stateManager.getAllTasks().forEach(task => {
                    this.orbitData.set(task.id, {
                        centerX: task.coords.x,
                        centerY: task.coords.y,
                        radius: this.orbitRadius,
                        speed: this.orbitSpeed,
                        angle: Math.random() * Math.PI * 2,
                        phase: Math.random() * Math.PI * 2
                    });
                });
            }

            updateAllOrbitData() {
                this.stateManager.getAllTasks().forEach(task => {
                    const orbit = this.orbitData.get(task.id);
                    if (orbit) {
                        orbit.radius = this.orbitRadius;
                        orbit.speed = this.orbitSpeed;
                    }
                });
            }

            setupEventListeners() {
                // Side menu toggle
                document.getElementById('side-menu-toggle').addEventListener('click', () => {
                    const sideMenu = document.getElementById('side-menu');
                    sideMenu.classList.toggle('visible');
                });

                // Side menu buttons
                document.getElementById('new-task').addEventListener('click', () => this.addNewTaskAtCenter());
                document.getElementById('save-state').addEventListener('click', () => this.saveState());
                document.getElementById('time-travel').addEventListener('click', () => this.showTimeTravel());
                document.getElementById('export-json').addEventListener('click', () => this.exportData());
                document.getElementById('import-json').addEventListener('click', () => this.importData());
                document.getElementById('orbit-mode').addEventListener('click', () => this.toggleOrbitMode());
                document.getElementById('reset-camera').addEventListener('click', () => this.resetCamera());
                
                // Depth button event listeners
                document.querySelectorAll('.depth-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const depth = parseInt(btn.dataset.depth);
                        this.addNewTaskAtDepth(depth);
                    });
                });

                // Speed control event listeners
                document.getElementById('orbit-radius').addEventListener('input', (e) => {
                    this.orbitRadius = parseFloat(e.target.value);
                    this.updateAllOrbitData();
                });
                
                document.getElementById('orbit-speed').addEventListener('input', (e) => {
                    this.orbitSpeed = parseFloat(e.target.value);
                    this.updateAllOrbitData();
                });
                
                document.getElementById('card-drag-speed').addEventListener('input', (e) => {
                    this.cardDragSpeed = parseFloat(e.target.value);
                });
                
                document.getElementById('universe-drag-speed').addEventListener('input', (e) => {
                    this.universeDragSpeed = parseFloat(e.target.value);
                });

                // Modal
                document.getElementById('modal-save').addEventListener('click', () => this.saveTask());
                document.getElementById('modal-cancel').addEventListener('click', () => this.closeModal());

                // Time travel modal
                document.getElementById('time-travel-cancel').addEventListener('click', () => this.closeTimeTravel());

                // Context menu
                document.getElementById('context-menu').addEventListener('click', (e) => {
                    const action = e.target.dataset.action;
                    const taskId = e.target.parentElement.dataset.taskId;
                    if (action && taskId) {
                        this.handleContextAction(action, taskId);
                    }
                    document.getElementById('context-menu').style.display = 'none';
                });

                // Close context menu on outside click
                document.addEventListener('click', () => {
                    document.getElementById('context-menu').style.display = 'none';
                });

                // Universe dragging with infinite navigation
                const canvas = document.getElementById('main-canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    if (e.target === canvas && !this.taskRenderer.draggedTask) {
                        this.isDraggingUniverse = true;
                        this.lastMousePos = { x: e.clientX, y: e.clientY };
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (this.isDraggingUniverse) {
                        const deltaX = e.clientX - this.lastMousePos.x;
                        const deltaY = e.clientY - this.lastMousePos.y;
                        
                        this.camera.x -= deltaX * this.universeDragSpeed;
                        this.camera.y += deltaY * this.universeDragSpeed;
                        
                        // Update all task positions when universe moves
                        this.stateManager.getAllTasks().forEach(task => {
                            this.taskRenderer.updateTaskPosition(task);
                        });
                        
                        this.lastMousePos = { x: e.clientX, y: e.clientY };
                        e.preventDefault();
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    this.isDraggingUniverse = false;
                    canvas.style.cursor = 'grab';
                });

                // Proper 3D zooming
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoom = Math.max(0.1, Math.min(20, this.zoom * zoomFactor));
                    this.camera.z = 5 / this.zoom;
                    
                    // Update all task positions after zoom
                    this.stateManager.getAllTasks().forEach(task => {
                        this.taskRenderer.updateTaskPosition(task);
                    });
                });

                // Touch events for mobile
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1 && e.target === canvas && !this.taskRenderer.draggedTask) {
                        this.isDraggingUniverse = true;
                        this.lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        e.preventDefault();
                    }
                });

                canvas.addEventListener('touchmove', (e) => {
                    if (this.isDraggingUniverse && e.touches.length === 1) {
                        const deltaX = e.touches[0].clientX - this.lastMousePos.x;
                        const deltaY = e.touches[0].clientY - this.lastMousePos.y;
                        
                        this.camera.x -= deltaX * this.universeDragSpeed;
                        this.camera.y += deltaY * this.universeDragSpeed;
                        
                        // Update all task positions when universe moves
                        this.stateManager.getAllTasks().forEach(task => {
                            this.taskRenderer.updateTaskPosition(task);
                        });
                        
                        this.lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        e.preventDefault();
                    }
                });

                canvas.addEventListener('touchend', () => {
                    this.isDraggingUniverse = false;
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case '1': this.filterByPriority('high'); break;
                        case '2': this.filterByPriority('medium'); break;
                        case '3': this.filterByPriority('low'); break;
                        case 'n': this.addNewTaskAtCenter(); break;
                        case 'z': this.addNewTaskAtDepth(-5); break;
                        case 'x': this.addNewTaskAtDepth(0); break;
                        case 'c': this.addNewTaskAtDepth(10); break;
                        case 'v': this.addNewTaskAtDepth(5); break;
                        case 'escape': 
                            this.closeModal(); 
                            this.closeTimeTravel();
                            break;
                        case 'w': 
                            this.camera.y += 0.1; 
                            this.stateManager.getAllTasks().forEach(task => {
                                this.taskRenderer.updateTaskPosition(task);
                            });
                            break;
                        case 's': 
                            this.camera.y -= 0.1; 
                            this.stateManager.getAllTasks().forEach(task => {
                                this.taskRenderer.updateTaskPosition(task);
                            });
                            break;
                        case 'a': 
                            this.camera.x -= 0.1; 
                            this.stateManager.getAllTasks().forEach(task => {
                                this.taskRenderer.updateTaskPosition(task);
                            });
                            break;
                        case 'd': 
                            this.camera.x += 0.1; 
                            this.stateManager.getAllTasks().forEach(task => {
                                this.taskRenderer.updateTaskPosition(task);
                            });
                            break;
                        case 'q': 
                            this.camera.z += 0.1; 
                            this.stateManager.getAllTasks().forEach(task => {
                                this.taskRenderer.updateTaskPosition(task);
                            });
                            break;
                        case 'e': 
                            this.camera.z -= 0.1; 
                            this.stateManager.getAllTasks().forEach(task => {
                                this.taskRenderer.updateTaskPosition(task);
                            });
                            break;
                    }
                });

                // Add new task on double-click empty space
                canvas.addEventListener('dblclick', (e) => {
                    if (e.target === canvas) {
                        this.addNewTaskAtPosition(e.clientX, e.clientY);
                    }
                });
            }

            initializeTasks() {
                const tasks = this.stateManager.getAllTasks();
                if (tasks.length === 0) {
                    const sampleTasks = [
                        { title: 'Welcome to To-Do Universe', brief: 'Your tasks float in 3D space', priority: 'high', coords: { x: 0, y: 0, z: 0 } },
                        { title: 'Drag to move', brief: 'Click and drag cards to reposition them', priority: 'medium', coords: { x: 2, y: 1, z: 0 } },
                        { title: 'Right-click for menu', brief: 'Access edit, duplicate, and delete options', priority: 'low', coords: { x: -2, y: -1, z: 0 } }
                    ];

                    sampleTasks.forEach(taskData => {
                        this.stateManager.addTask(new Task(taskData));
                    });
                }

                this.stateManager.getAllTasks().forEach(task => {
                    this.taskRenderer.addTask(task);
                });
            }

            saveTask() {
                const taskId = document.getElementById('modal').dataset.editingTaskId;
                const task = this.stateManager.getTask(taskId);
                
                if (task) {
                    const title = document.getElementById('modal-title').value;
                    const brief = document.getElementById('modal-brief').value;
                    const links = document.getElementById('modal-links').value.split(',').map(l => l.trim()).filter(l => l);
                    const tags = document.getElementById('modal-tags').value.split(',').map(t => t.trim()).filter(t => t);
                    const priority = document.getElementById('modal-priority').value;

                    task.update({ title, brief, links, tags, priority });
                    this.taskRenderer.removeTask(taskId);
                    this.taskRenderer.addTask(task);
                    
                    this.messageManager.success('Task updated successfully');
                }
                
                this.closeModal();
            }

            closeModal() {
                document.getElementById('modal').style.display = 'none';
            }

            handleContextAction(action, taskId) {
                const task = this.stateManager.getTask(taskId);
                if (!task) return;

                switch(action) {
                    case 'edit':
                        this.taskRenderer.editTask(task);
                        break;
                    case 'duplicate':
                        const newTask = new Task({
                            ...task,
                            id: undefined,
                            coords: { x: task.coords.x + 1, y: task.coords.y + 1, z: task.coords.z }
                        });
                        this.stateManager.addTask(newTask);
                        this.taskRenderer.addTask(newTask);
                        this.messageManager.success('Task duplicated');
                        break;
                    case 'follow':
                        this.camera.x = task.coords.x;
                        this.camera.y = task.coords.y;
                        this.messageManager.info('Camera focused on task');
                        break;
                    case 'delete':
                        this.stateManager.deleteTask(taskId);
                        this.taskRenderer.removeTask(taskId);
                        this.messageManager.success('Task deleted');
                        break;
                }
            }

            saveState() {
                this.stateManager.saveToStorage();
                this.messageManager.success('State saved to localStorage');
            }

            exportData() {
                const data = this.stateManager.exportJSON();
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `todo-universe-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                this.messageManager.success('Data exported successfully');
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            if (this.stateManager.importJSON(e.target.result)) {
                                // Clear existing tasks
                                this.stateManager.getAllTasks().forEach(task => {
                                    this.taskRenderer.removeTask(task.id);
                                });
                                
                                // Add imported tasks
                                this.stateManager.getAllTasks().forEach(task => {
                                    this.taskRenderer.addTask(task);
                                });
                                
                                this.messageManager.success('Data imported successfully');
                            } else {
                                this.messageManager.error('Failed to import data');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            showTimeTravel() {
                const modal = document.getElementById('time-travel-modal');
                const entriesContainer = document.getElementById('time-entries');
                
                const savedStates = this.stateManager.getSavedStates();
                
                if (savedStates.length === 0) {
                    entriesContainer.innerHTML = '<p>No saved states available</p>';
                } else {
                    entriesContainer.innerHTML = savedStates.map(state => `
                        <div class="time-entry" data-index="${state.index}">
                            <strong>${state.description}</strong><br>
                            <small>${new Date(state.timestamp).toLocaleString()}</small>
                        </div>
                    `).join('');
                    
                    // Add click handlers
                    entriesContainer.querySelectorAll('.time-entry').forEach(entry => {
                        entry.addEventListener('click', () => {
                            const index = parseInt(entry.dataset.index);
                            this.timeTravelTo(index);
                        });
                    });
                }
                
                modal.style.display = 'flex';
            }

            closeTimeTravel() {
                document.getElementById('time-travel-modal').style.display = 'none';
            }

            timeTravelTo(index) {
                if (this.stateManager.loadState(index)) {
                    // Clear existing tasks
                    this.stateManager.getAllTasks().forEach(task => {
                        this.taskRenderer.removeTask(task.id);
                    });
                    
                    // Add tasks from the loaded state
                    this.stateManager.getAllTasks().forEach(task => {
                        this.taskRenderer.addTask(task);
                    });
                    
                    this.initializeOrbitData();
                    this.closeTimeTravel();
                    this.messageManager.success('Time travel successful!');
                } else {
                    this.messageManager.error('Failed to load state');
                }
            }

            addNewTaskAtCenter() {
                // Create task at center of screen
                const newTask = new Task({
                    title: 'New Task',
                    brief: 'Double-click to edit',
                    coords: { 
                        x: 0, 
                        y: 0, 
                        z: 0
                    },
                    priority: 'medium'
                });
                
                this.stateManager.addTask(newTask);
                this.taskRenderer.addTask(newTask);
                this.orbitData.set(newTask.id, {
                    centerX: 0,
                    centerY: 0,
                    radius: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.02 + 0.01,
                    angle: Math.random() * Math.PI * 2,
                    phase: Math.random() * Math.PI * 2
                });
                
                this.messageManager.success('New task created at center');
            }

            addNewTaskAtDepth(depth) {
                const newTask = new Task({
                    title: 'New Task',
                    brief: 'Double-click to edit',
                    coords: { x: this.camera.x, y: this.camera.y, z: depth },
                    priority: 'medium'
                });
                
                this.stateManager.addTask(newTask);
                this.taskRenderer.addTask(newTask);
                this.orbitData.set(newTask.id, {
                    centerX: this.camera.x,
                    centerY: this.camera.y,
                    radius: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.05 + 0.03,
                    angle: Math.random() * Math.PI * 2,
                    phase: Math.random() * Math.PI * 2
                });
                
                this.messageManager.success(`New task created at depth ${depth}`);
            }

            addNewTaskAtPosition(screenX, screenY) {
                // Convert screen coordinates to world coordinates
                const worldX = (screenX - window.innerWidth / 2) * 0.01;
                const worldY = (window.innerHeight / 2 - screenY) * 0.01;
                
                const newTask = new Task({
                    title: 'New Task',
                    brief: 'Double-click to edit',
                    coords: { x: worldX, y: worldY, z: 0 },
                    priority: 'medium'
                });
                
                this.stateManager.addTask(newTask);
                this.taskRenderer.addTask(newTask);
                this.orbitData.set(newTask.id, {
                    centerX: worldX,
                    centerY: worldY,
                    radius: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.05 + 0.03,
                    angle: Math.random() * Math.PI * 2,
                    phase: Math.random() * Math.PI * 2
                });
                
                this.messageManager.success('New task created');
            }

            toggleOrbitMode() {
                this.orbitMode = !this.orbitMode;
                const button = document.getElementById('orbit-mode');
                button.innerHTML = this.orbitMode ? '<span>⏸️</span> Pause Orbit' : '<span>🔄</span> Orbit Mode';
                this.messageManager.info(this.orbitMode ? 'Orbit mode activated' : 'Orbit mode deactivated');
                
                if (this.orbitMode) {
                    // Store current positions as orbit centers
                    this.stateManager.getAllTasks().forEach(task => {
                        if (!this.orbitData.has(task.id)) {
                            this.orbitData.set(task.id, {
                                centerX: task.coords.x,
                                centerY: task.coords.y,
                                radius: Math.random() * 2 + 0.5,
                                speed: Math.random() * 0.05 + 0.03,
                                angle: Math.random() * Math.PI * 2,
                                phase: Math.random() * Math.PI * 2
                            });
                        }
                    });
                }
            }

            updateOrbitalMotion() {
                if (!this.orbitMode) return;
                
                this.stateManager.getAllTasks().forEach(task => {
                    const orbit = this.orbitData.get(task.id);
                    if (orbit) {
                        orbit.angle += orbit.speed;
                        
                        task.coords.x = orbit.centerX + Math.cos(orbit.angle + orbit.phase) * orbit.radius;
                        task.coords.y = orbit.centerY + Math.sin(orbit.angle + orbit.phase) * orbit.radius;
                        
                        this.taskRenderer.updateTaskPosition(task);
                    }
                });
            }

            resetCamera() {
                this.camera = { x: 0, y: 0, z: 5 };
                this.zoom = 1;
                this.messageManager.info('Camera reset to origin');
            }

            filterByPriority(priority) {
                this.messageManager.info(`Filtering by ${priority} priority`);
                // Implementation for filtering would go here
            }



            startRenderLoop() {
                const render = () => {
                    this.starfield.render(this.camera);
                    this.radar.render(this.stateManager.getAllTasks(), this.camera);
                    this.updateOrbitalMotion();
                    requestAnimationFrame(render);
                };
                render();
            }
        }

        // Initialize the application
        const app = new TodoUniverse();
        window.app = app; // Make globally available for task dragging
        app.messageManager.info('To-Do Universe initialized');
        app.messageManager.success('Welcome to your cosmic task manager');
    </script>
</body>
</html>